/* Write a method that returns all subsets of a set */
#include <iostream>
#include <iomanip>
#include <stdlib.h>
#include <vector>

using namespace std;

/* — интервьюером необходимо обсудить следующие вещи:
   1.  аким образом представлено исходное множество?
   2. ¬ каком виде нужно вернуть подмножества?
   3. ¬озможно, что способ представлени€ множества допускает
      существование дубликатов. ≈сли это так, то спросить, нужно ли
      как-то учесть этот момент или можно считать, что дубликатов нет.
      ≈сли дубликаты могут быть, то что делать: проверить вход и упасть
      или сформировать подмножества уже с учетом дубликатов (т.е. не
      включать дубликаты в каждое результирующее подмножество более, чем один раз)?
   4. ¬ реальности сгенерировать все подмножества можно только дл€ коротких множеств.
      ѕоэтому надо спросить интервьюера, чего он хочет:
      a) простое рекурсивное решение (отличаетс€ тормознутостью + не подходит дл€
         очень больших множеств, т.к. может свалитьс€ из-за переполнени€ стека)
      б) решение на битовых векторах. ѕричем может быть два вида решени€:
            - битовый вектор умещаетс€ в стандартный целочисленный формат (это решение
              не годитс€ дл€ больших множеств)
            - большой битовый вектор на массиве из стандартных форматов (тут уже возникают
              проблемы с генерацией самих векторов)
      в) оптимальное решение (без рекурсии и битовых векторов)

      ƒумаетс€, что в любом случае надо выбирать оптимальное решение и реализовывать именно его

      ƒалее приводитс€ решение с битовым вектором на int-формате
*/
vector< vector<int> > getSubsets( vector<int> &num_set)
{
    if ( num_set.size() > sizeof( int) << 3 )
    {
        cout << "Too big set";

        exit( 1);
    }

    vector< vector<int> > result( 1 << num_set.size());
    int ind = 0;

    for ( int i = 0; i < 1 << num_set.size(); i++ )
    {
        vector<int> subset;
        int num = i, j = 0;

        while ( num )
        {
            if ( num & 1 )
                subset.push_back( num_set[j]);

            j++;
            num >>= 1;
        }

        result[ind++] = subset;
    }

    return result;
}

int main()
{
    const int n = 4;
    vector<int> num_set( n);

    cout << "Set: ";
    for ( int i = 0; i < n; i++ )
    {
        num_set[i] = i;
        cout << setw( 3) << num_set[i];
    }

    cout << "\nSubsets: \n";

    vector< vector<int> > subsets = getSubsets( num_set);

    for ( int i = 0; i < subsets.size(); i++ )
    {
        for ( int j = 0; j < subsets[i].size(); j++ )
            cout << setw( 3) << subsets[i][j];

        cout << "\n";
    }

    return 0;
}
